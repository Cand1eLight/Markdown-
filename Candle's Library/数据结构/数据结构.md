## 绪论

- 数据：能够输入计算机且能被计算机处理的**各种符号的集合**
    
- 数据元素：数据的**基本单位**，在计算机程序中通常作为一个整体进行考虑和处理
    
- 数据项：构成数据元素的不可分割的**最小单位**
    

数据>数据元素>数据

- 数据对象：**性质相同的数据元素的集合**，是数据的一个子集
    
    比如整数，浮点数，字母字符，或是学籍表
    
- _**数据结构**_
    
    - 数据元素之间的逻辑关系，逻辑结构
        
        - 线性结构：所有节点最多只有一个前驱和后继：线性表，栈和队列
            
        - 非线性结构：一个节点可能有多个直接前驱和直接后继：树，图
            
    - 数据元素及其关系在计算机内存中的表示，成为物理结构或者存储结构
        
        - 顺序存储结构：用_连续_ 的存储单元_依次_存储数据元素，数据元素之间的逻辑关系有元素的来表示
            
            C语言中用数组来实现顺序存储结构
            
        - 链式存储结构：用一组**任意**的存储单元存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示
            
            C语言用指针来实现链式存储结构
            
        - 索引存储结构：在存储节点信息的同时还能建立附加的索引表
            
        - 散列存储结构：根据节点关键字直接得出（略）
            
    - 数据的运算和实现，对数据元素施加操作
        
    
    存储结构与逻辑结构的关系，逻辑结构是数据结构的抽象，存储结构是数据结构的实现
    
- **数据类型和抽象数据类型**
    
    - 对程序中出现的每个变量、常量或表达式，明确说明他们所属于的**数据类型**（基本数据类型，数组之类的构造数据类型，指针类型，自定义数据类型）用于规定范围与约束操作
        
        - ==数据类型==是一组性质相同的**值的集合**以及定义于这个值集合以及定义于这个值集合上的**一组操作**的总称
            
    - **抽象数据类型**
        
        - 指一个数学模型以及定义在此数学模型上的一组操作
            
        - 形式定义：包含了数据对象，数据对象上的关系集，对数据对象的基本操作 D S P
            
        - 抽象数据==形式定义==：
            
            ADT 抽象数据类型名字{  
             数据对象：<数据对象的定义>  
             数据关系：     关系  
             基本操作： 基本操作的定义  
            }ADT 抽象数据类型名
            
            ---
            
            _基本操作_ 定义格式说明：
            
            - 参数表：赋值参数 只为操作提供输入值 ；引用参数 以&开头，还会返回操作结果
                
            - 初始条件
                
            - 操作结果
                
            - 例子：![image-20230930151744573](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20230930151744573.png?lastModify=1699273014)
                
            
            ADT Circle{  
             数据对象D={r,x,y|r,x,y均为实数}  
             数据关系R={<r,x,y>|r是半径，<x,y>是圆心坐标}  
             基本操作：  
             Circle(&C,r,x,y)  
                操作结果：构造一个圆。  
             dounble Area(C)  
                初始条件：圆存在  
                操作结果：计算面积  
             double Circumference(C)  
                初始条件：圆存在  
                操作结果：计算周长   
            }ADT Circle //以上都是伪代码，具体代码有待编写
            
            tips：凡是需要返回值的都需要使用‘&’符号
            
- **抽象数据类型的表示与实现**
    
    - 概念小结![image-20230930152914563](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20230930152914563.png?lastModify=1699273014)
        
    - 如何实现抽象数据类型
        
        - 通过固有的数据类型来表示和实现→利用处理器中已经存在的数据类型来说明新的结构，用已经实现的操作来组成新的操作
            
            void assign (complex *A,float real,float imag){  
                A ->realpart = real;  
                A -> imagpart = imag;  
            }
            
- **算法和算法分析**
    
    - 算法的定义：对特定问题 _求解方法和步骤_的一种描述，他是指令的有限序列
        
    - 算法的描述：自然语言→英语、中文，伪代码，C语言
        
    - 算法与程序
        
        - 算法是解决问题的一种方法或一个过程
            
        - 程序是用，欧总程序设计语言对算法的实现
            
    - 算法特性：
        
        - 有穷性：步骤必须有限，每一步的时间也是有限的
            
        - 确定性： 每一条指令都必须有确切的含义，没有异议
            
        - 可行性：算法是可以执行的
            
        - 输入：一个算法有0或多个输入
            
        - 输出：一个算法有一个或多个输出
            
    - 算法设计要求
        
        - 正确性，可读性，健壮性，高效性
            
    - 算法分析
        
        - 时间效率
            
            - 程序在计算机上执行所消耗的时间
                
            - 事后统计：将算法实现测算时间和空间开销→与环境有关
                
            - 事前估算：计算时间复杂度（算法运行时间=一个简单操作所需时间×简单操作次数）= 每条语句频度之和*每条语句所花费时间
                
            - 算法的渐进时间复杂度 T(n)=O(f(n))
                
                - 感觉比较简单，只要求关注算法的主要语句的次数即可
                    
                - 随着问题的_输入的数据集_ 不同而不同
                    
        - 空间效率
            
            - 空间复杂度：算法所需储存空间的度量S(n)=O(F(n))
                
    
    ## 线性表
    
- 线性表的定义和特点
    
    - **线性表**是具有相同特性的数据元素的优先序列![image-20231001100344975](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231001100344975.png?lastModify=1699273014)
        
    - 在非空的线性表中，有且仅有一个开始节点a1，没有直接前驱，而仅有一个直接后继
        
    - 线性表中数据元素的类型可以使简单类型，也可以是复杂类型
        
    - 许多实际应用问题所涉及的基本操作有很大的相似性，不应该为每个具体应用单独编写一个程序
        
    - 从具体应用抽象出共性的**逻辑结构和基本操作**，然后实现其存储结构和基本操作
        
- 线性表的类型定义
    
    - 抽象数据类型线性表的定义如下：还是经典的数据对象，数据关系，基本操作
        
    - 基本操作
        
        - InitList:操作结果：构造一个空的线性表；
            
        - DestoryList（&L）：初始条件：线性表已经存在。操作结果：销毁线性表L；
            
        - ListEmpty(L)初始条件：线性表存在 操作结果：线性表为空表返回ture，否则返回false；
            
        - GetElem(L,i,&e)初始条件：线性表存在，1<=i<=ListLength(L) 操作结果：用e返回线性表L中第i个数据元素的值
            
        - LocateElem（L,e,compare())初始条件：线性表存在，compare()是数据元素判定函数 操作结果：返回L中第一个与e妈祖compare（）数据元素的维修。若这样的数据元素不存在则返回值为0
            
        - PriorElem(L,cur_e,&pre_e) 初始条件：线性表存在 操作结果……![image-20231001104334388](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231001104334388.png?lastModify=1699273014)
            
        - ListInsert(&L,i,e) 将元素插入线性表![image-20231001104454100](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231001104454100.png?lastModify=1699273014)
            
        - ListDelete(&l,i,&e) ListTraverse(&L,visited()) 删除线性表中的元素每一集访问线性表中的元素![image-20231001104727326](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231001104727326.png?lastModify=1699273014)
            
        - 以上提到的运算是逻辑结构上的定义的运算，需要学习如何实现以上的这些操作
            
- 线性表的顺序表示和实现
    
    - 线性表的孙雪表示又称为顺序存储结构或者顺序映像
        
    - **顺序存储定义**：把逻辑上相邻的数据元素村吃在物理上的相邻存储单元中的存储结构
        
    - 线性表顺序存储结构占用一片连续的存储空间，已知一个的存储位置则可以推断其他元素所占位置：LOC(ai+1)=LOC(ai)+(i-1)*l
        
    - 顺序表（元素）→数组（元素） 用一维数组表示顺序表
        
        - 地址连续
            
        - 依次存放
            
        - 随机存取
            
        - 类型相同
            
    - 线性表长度可变（删除） 数组长度不可动态定义 →用以变量表示顺序表的长度属性
        
- 补充：类C语言有关操作
    
    - 顺序表类型定义
        
        - ==ElemTpye== data[] 高亮字体代指数据类型，具体可以是char,float……
            
    - 数组定义
        
        - 数组的静态分配与动态分配，都是存放的数组第一个元素的地址，前者不可变，后者可变，*data为首元素地址![image-20231001111347131](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231001111347131.png?lastModify=1699273014)
            
    - C语言的内存动态分配 先计算变量的长度，然后在开辟所需空间，一个元素需要的字节数乘以maxsize，前面的就是指向什么类型的指针![image-20231001111559975](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231001111559975.png?lastModify=1699273014)
        
    - c++的动态存储分配![image-20231001113639627](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231001113639627.png?lastModify=1699273014)
        
    - C++的参数传递
        
        - 函数调用时传递给形参的实参必须有三个一致：类型、个数、顺序
            
        - 参数传递有两个方式
            
            - 传值方式
                
            - 传地址：指针变量、数组名、引用类型![image-20231002143759514](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231002143759514.png?lastModify=1699273014)
                
            - 形参变化影响实参![image-20231002144210113](file://C:/Users/20418/Desktop/Collection/Study%20record/MarkDown/image-20231002144210113.png?lastModify=1699273014)
                
            - 形参不影响实参![image-20231002144904868](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231002144904868.png?lastModify=1699273014)
                
            - 使用数组名字作为参数
                
                - 传递的是数组的首地址
                    
                - 对形参数组所做的任何改变都会反映到实参数组中
                    
            - 引用类型作为参数：他用来给一个对象提供一个替代的名字![image-20231002145225053](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231002145225053.png?lastModify=1699273014)形参变量的值是是参变量的副本，数据量大的时候表现突出
                
- 线性表的顺序存储表示
    
    - 从逻辑结构存储到存储结构![image-20231002150310211](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231002150310211.png?lastModify=1699273014)==逻辑位序==和==物理位序==相差1
        
    - 顺序表也是一个结构类型，例如：SqList L；就是定义一个顺序表
        
        #define maxsize 100  
        typedef struct{  
            ElemType *elem;  
            int lengthl  
        }SqLost; //定义顺序表类型 elemtype 就是顺序表的数据类型（多种
        
    - 线性表L的初始化（参数用引用）
        
        Status InitList Sq(SqList &L)  
        {  
            L.elem = new ElemTypr[maxsize];//为顺序表分配空间  
            if(!L.elem) exit (OVERFLOW);//存储空间四边  
            L.lenth = 0;//空表的长度为0  
            return OK;  
        }
        
    - 销毁线性表L
        
        void DestoryList(SqList &L){  
            if (L.elem) delete L.elem;//释放存储空间  
        }
        
    - 清空线性表
        
        void ClearList(SqList &L){  
            L.length = 0;  
        }
        
    - 求线性表L 的长度
        
        int GetLength(SqList L){  
            return (L.length);  
        }
        
    - 判断线性表L是否为空表
        
    
    int IsEmpty(SqList L){  
        if (L.length == 0) return 1;  
        else return 0;  
    }
    
    - 顺序表的取值（根据位置i获取对应位置数据元素的内容）
        
        int GetElem (SqList L。int i,Elem Type &e){  
            if(i<1||i>L.length) return ERROR;  
            //判断i的值是否合理，不合理就返回ERROR  
            e = L.elem[i-1];  
            return OK;  
        }
        
    - 顺序表的查找（按值查找）
        
        int LocatElem(SqList l,ElemType e){  
            //在线性表中查找e的数据元素，返回其序号  
            for(i = 0;i<l.length;i++)  
                if(l.elem[i]==e) return i+1;//查找成功返回序号  
            return 0; //查找失败返回0  
        }
        
    - 顺序表的插入
        
        - 插入位置在最后 直接插入
            
        - 插入位置在中间 将待插入的位置后面的数都向后移一格
            
        - 插入位置在最前面 同上
            
        - 算法设计思想： 插入位置是否合法，顺序表存储空间是否已满，如果已经满了，则返回error ；从最后一个一直到待插入的位置后的所有元素向后移动一个位置；将e放入第i个位置；表长+——1
            
        - status ListInsert_Sq(Sqlist &L,int i,ElemType e){  
                if(i<1||i>L.length+1) retrurn ERROR;  
                if(L.length == MAXSIZE) return ERROR;  
                for(j=L.length-1;j>=i-1;j--)  
                    L.elem[j+1]=L.elem[j];  
                L.elem[i-1] = e;  
                L.length ++;  
                return OK;  
            }
            
        - 算法时间消耗：插入结点位置不同导致计算时间不同 ，时间复杂度就是求解所需时间的平均值，最后一般归类为等差数列或是等比数列
            
    - 顺序表的删除算法
        
        - 删除的位置在最后面 直接删除
            
        - 删除的位置在中间 删除的后面的每个元素向前移动
            
        - 删除的位置在最前面 同上，从第二个开始到最后一个元素全部向前移一格
            
        - 算法设计思想：判断删除位置是否合法；将后面的元素依次向前移动；表长减一；
            
        - Status ListDelet Sq(SqList &L,int i){  
                if(i<1||i>L.length) return ERROR;  
                for (j=i;j<=L.length-1;j++)  
                    L.elem[j-1]=L.elem[j];  
                L.length--;  
                  
                return OK;  
            }
            
        - 删除算法和插入算法的时间复杂度都是O(n)
            
- 线性表的链式存储
    
    - 需要存储数据结构本身和指针域
        
    - 结点：数据元素的存储映像，数据域和指针域
        
    - 链表：n个元素形成的链表，逻辑顺序和物理顺序不再一致
        
    - 单链表、双链表、循环链表![image-20231002171517568](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231002171517568.png?lastModify=1699273014)
        
    - 头指针、头结点、首元结点![image-20231002171612221](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231002171612221.png?lastModify=1699273014)
        
    - 讨论的一些问题
        
        - 如何表示空表？头指针的指针域是否为空
            
        - 链表中设置头结点有什么好处？ 便于首元结点的处理，无需进行特殊处理；便于空表和非空表的处理
            
        - 头结点的数据域内装的是什么？ 头结点的数据与可以为空，也可以存放表长等数据
            
    - 链表的特点
        
        - 位置是任意的，物理上不一定相连
            
        - 访问只能通过头结点进入链表，一次向后顺序扫描其余结点
            
    - 带头结点的单链表
        
        - 单链表是由表头唯一确定的，因此单链表可以用头指针的名字来命名，若头指针名是L，则把链表称为表L![image-20231002191643496](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231002191643496.png?lastModify=1699273014)
            
        - type struct Lnode{//声明结点的类型和指向指针的指针类型  
                ElemType data; //节点的数据域  
                struct Lnode *next; // 节点的指针域  
            }Lnode,*LinkList; //LinkList 为指向结构体Lnode的指针类型
            
        - 定义链表L：LinkList L ； 定义结点指针p：LNode *p → LinkList p；
            
        - 例如：存储学生学号、姓名、成绩的单链表结点类型定义如下：
            
            typedef Struct student {  
                cahr num[8]; //数据域  
                char name[8]; ……  
                int score;……  
                struct student *next; //指针域  
            }Lnode,*LinkList;
            
            typedef Struct{  
                char num[8]; //数据域  
                char num[8];……  
                int score; ……  
            }ElemType;  
            ​  
            typedef struct Lnode{  
                ElemType data; //数据域  
                struct Lnode *next; // 指针域  
            }node,*LinkList;
            
    - 单链表的基本操作的实现
        
        - 单链表的初始化 ： 构造一个空表
            
            Status LnitList L(LinkList &L){  
                L = new LNode; //L = (LinkList) malloc (sizeof (LNode));  从内存中找到一处空间，并赋值给L  
                L -> next = NULL; //将L的next域置为空  
            }
            
        - 判断链表是否为空：空表：链表中没有元素（头指针和头结点仍然存在）
            
            1. int ListEmpty(LinkList L){//若L为空表，则返回1，否则返回0  
                    if (L -> next) //非空  
                       return 0;  
                    else   
                       return 1;  
                }
                
        - 单链表的销毁
            
            - 算法思路：从头指针开始，依次释放所有节点
                
                Status DestroyList_L (LinkList &L){ //销毁单链表  
                    Lnode *p; //或LinkList p；  
                    while (L){  
                        p = L;  
                        L = L -> next;  
                        delete p;  
                    }  
                }
                
        - 清空单链表
            
            - 算法思路：依次释放所有结点，并将头结点指针域设置为空
                
                Status ClearList(LinkList &L){  
                    Lnode *p ,*q;  
                    p = L -> next;  
                    while (p){ //没到空表  
                        q = p -> next;  
                        delete p;  
                        p=q;  
                    }  
                    L -> next = NULL;  
                    return OK; //头指针为NULL  
                }
                
        - 求单链表的表长
            
            - 算法思路：从首元结点开始，依次计数所有的节点
                
                int ListLength_L(LinkLIst L){  
                    LinkList p;  
                    p = L -> next; //p指向第一个节点  
                    i = 0；  
                    while(p){  
                        i++;  
                        p = p-> next;  
                    }  
                      
                    return i;  
                }
                
        - 单链表的基本操作
            
            - ![image-20231002212150295](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231002212150295.png?lastModify=1699273014)
                
            - 取值——取单链表中第i个元素的内容
                
                - 算法思路：分别取出表中的第三个元素和第十五个元素（从链表的头指针出发，逐个寻找，链表不是随机存储的）
                    
                    Status GetElem L(LinkList L,int i,ElemType &e){ //获取线性表L中的某个数据的内容，通过变量e返回  
                      P = L -> next;  
                      j = 1; // 初始化  
                        while(p&&j<i){ // 向后扫描，直到p指向第i个元素或p为空  
                            p = p -> next;  
                            ++j;  
                        }  
                        if(!p||j>i) return ERROR; //第i个元素不存在  
                        e = p -> data; //取第i个元素  
                        return OK;  
                    } // GetElem_L
                    
            - 按值查找——根据指定数据获取该数据所在的位置（地址）
                
                - 算法思路：从第一个开始比较，如果找到则返回“位置”，如果没有就返回NULL或者0
                    

    ~~~c++  
    Lnode *LocateElem_L (LinkList L,Elemtype e){  
        //在线性表L中查找值为e的数据元素  
        //找到，则返回位置，查找失败就返回NULL  
          
        p = L -> next;  
        while(p&&p->data!=e)  
            p = p->next;  
       return p;  
    }  
    ~~~  
​  
    ~~~c++  
    //在线性表L中查找值为e的数据元素的位置序号  
    int LocateElem_L (LinkList L,Elemtype e){  
        //返回L中值为e的数据元素的位置序号，查找失败返回0  
        p = L->next.  
            j=1;  
        while(p&&p->data!=e)  
        {  
            p = p->next;  
            j++;  
        }  
        if(p) return j;  
        else return 0;  
    }  
    ~~~  
​  
  - 插入——在第i个结点前插入值为e的新节点  
​  
    - 算法思路：找到a~i-1~和存储位置p，在生成一个数据域为e的新节点s；再插入新节点，将新节点的指针域指向a~i~，在将a~i-1~的指针域指向新节点  
​  
      ~~~c++  
      //在L中第i个元素之前插入数据元素e  
      Status ListInsert_L(LinkList & L.int i,ElemType e){  
          p = L;  
          j = 0;  
          while(p&&j<i-1){ //寻找第i-1个结点，p指向i-1结点  
              p = p->next;  
              ++j;  
          }  
          if(!p||j>i-1) return ERROR;//i大于表长+1或者小于1，则表示插入位置非法  
          s - new LNode; // 生成新节点s，将结点s的数据域置为e  
          s -> data = e;  
          s -> next = p->next; //将结点s插入L中  
          p -> next = s;  
          return OK;  
      } //ListInsert_L  
      ~~~  
​  
  - 删除——删除第i个结点  
​  
    - 算法思路：找到a~i-1~的存储位置p，保留要删除的a~I~的值；令 p -> next 指向a~i+1~；释放结点a~i~的空间  
​  
      ~~~c++  
      Status ListDelete_L(LinkList &L,int i,ElemType &e){  
          p =   L;  
          j = 0;  
          while(p -> next && j<i-1){//寻找第i个结点，并令p指向其前驱  
              p=p->next;  
              ++j;  
          }  
          if(!(p -> next)||j>i-1) //删除位置不合理  
              return ERROR;  
          q = p -> next ; //临时保留被删除节点的地址以备释放  
          p->next=q->next ; //改变删除二级点前驱结点的指针域  
          e = p->data; //保留删除结点的数据域  
          delete q; //释放删除结点的空间  
          return OK;  
      } //ListDelete_L  
      ~~~  
​  
  - 单链表的建立  
​  
    - 头插法：元素插入在链表头部  
​  
      ~~~c++  
      void CreateList_H(LinkList &L,int n){  
          L = new Lnode;  
          L -> next = NULL; //建立一个带头结点的单链表  
          for(i=n;i>0;--i){  
              p = new Lnode;//生成新节点p  
              cin >> p-> data;//输入元素值  
              p->next = L->next;//插入到表头  
              L ->next =p; //开始循环  
          }  
      }//CreateList_H  
      ~~~  
​  
    - 后插法：元素插入在链表尾部  
​  
      ~~~c++  
      void CreateList_R (LinkList &L,int n){  
          L = new LNode;  
          L->next=NULL;  
          r=L;  
          for(i=0;i<n;i++){  
              p = new LNode; //生成新节点，输入元素值  
              cin >> p->data;  
              p->next=NULL;  
              r->next =p; //插入到尾表  
              r=p; //r指向新的尾结点  
          }  
      } //CreatList_r  
      ~~~

- 循环链表
    
    - 一种头尾相接的链表 优点：从表中任意结点出发均可找到表中其他节点。
        
    - 注意：循环链表没有NULL指针，判断是否结束则判断是否为头指针
        
    - ![image-20231003160424588](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231003160424588.png?lastModify=1699273014)
        
        LinkList Connect(LinkList Ta,LinkList Tb){  
            p=Ta->next;  
            Ta->next = Tb->next->next; //p存放镖头结点  
            delete Tb->next; //Tb表头链接ta表尾  
            Tb -> next = p; //释放tb表头结点  
            return Tb; //修改指针  
        }
        
- 双向链表
    
    - prior||data||next
        
    - ![image-20231003162136687](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231003162136687.png?lastModify=1699273014)
        
    - 双向链表的插入
        
        - 算法思想![image-20231003162621172](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231003162621172.png?lastModify=1699273014)
            
        - void ListInsert_DuL(DuLinkList &L,int i,ElemTypr e){  
                if(!(p=GetElemP_Dul(L,i))) retirn ERROR;  
                s = new DuLNode;  
                s->data=e;  
                s->prior = p ->prior;  
                p->prior->next=s;  
                s->next=p;  
                p->prior=s;  
                return OK;  
            }ListInsert_DuL
            
    - 双向链表的删除
        
        - 算法思想![image-20231003163345155](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231003163345155.png?lastModify=1699273014)
            
        - void listdelete_dul(dulink &l,int i,elemtype &e){  
                if(!(p=getelemp_dul(l.i))) return ERROR;  
                e = p-> data;  
                p->prior ->next = p->next;  
                p->next->prior = p->prior;  
                free(p);  
                return OK;  
            }//ListDelete_DuL
            
    - 单链表，循环链表，双向链表的时间效率比比较
        
        ![image-20231003165559510](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231003165559510.png?lastModify=1699273014)
        
    - 线性表的合并
        
        - 问题描述：假设利用两个线性表La和Lb分别表示两个集合A和B，现要求一个新的集合A=AUB
            
        - 算法步骤
            
            void union (List &La,List Lb){  
                La_len=listlength(la);  
                lb_len-listlength(lb);  
                for(i=1;i<=lb_len;i++)  
                    GetElem(lb,i,e);  
                if(!locateelem(la,e))  
                    listinser(&la,++la_len,e);  
            }
            
    - 有序表的合并
        
        - 问题描述：线性表la和lb中非递减有序排列，合并后的lc认识非递减有序排列
            
        - 算法步骤：胡商检空表Lc；从La和Lb中逐个取出直至一个表为空，把另外一个非空表组合到后面
            
        - void mergelist_sq(sqlist la,sqlist lb,sqlist&lc){  
                pa=la.elem;  
                pb=lb.elem; //指针pa和pb的初值分别指向两个表的第一个元素  
                lc.length=la.length+lb.length; //新表的长度为两表的长度之和  
                lc.elem=new elemtype[lc.length];//为合并后的新表new一个数组空间  
                pc=lc.elem; //指针pc指向新表的第一个元素  
                pa_last=la.elem+la.length-1; //指针pa_last指向la表的最后一个元素（从基地址加上表长减一）  
                pb_last=lb.elem+lb.length-1;  
                while(pa>=pa_last&&pb<=pb_last){ //两个表都非空  
                    if(*pa<=*pb) *pc++=*pa++; //依次取得两表中较小的结点  
                    else *pc++=*pb++;  
                }  
                while(pa<=pa_last) *pc++=*pa++;  lb表到达表尾，la表中的剩余元素加入lc  while(pb<=pb_last) *pc++=*pb++;  
            } //mergelist_sq
            
        - 使用链表实现
            
            - ![image-20231003173046905](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231003173046905.png?lastModify=1699273014)
                
            - ![image-20231003173537708](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231003173537708.png?lastModify=1699273014)![image-20231003173544725](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231003173544725.png?lastModify=1699273014)
                
- **栈和队列**
    
    - 栈——后进先出
        
        - 是一个特殊的线性表，是==限定==仅在一段（通常是表尾）进行插入和删除操作的线性表。
            
        - 逻辑结构仍然是一对一，顺序栈和链栈存储都可以
            
        - 又称为后进后出的线性表，简称LIFO结构
            
        - 表尾称为栈顶 top；表头称为栈底 base
            
        - ![image-20231004143845232](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004143845232.png?lastModify=1699273014)
            
    - 队列——先行先出
        
        - 在表尾插入，在另一头（表头）删除
            
    - 案例：进制转换
        
        - 把十进制数159转化为八进制数![image-20231004145241364](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004145241364.png?lastModify=1699273014)
            
    - 案例：括号匹配的检验
        
        - ![image-20231004145435076](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004145435076.png?lastModify=1699273014)
            
    - 表达式求值
        
        - 算符优先算法![image-20231004145808434](file://C:/Users/20418/Desktop/Collection/Study%20record/MarkDown/image-20231004145808434.png?lastModify=1699273014)
            
    - 栈的首相数据类型的类型定义
        
        - 数据对象
            
        - 数据关系
            
        - 基本操作
            
    - 顺序栈的表示和实现
        
        - 同一般线性表的顺序存储结构完全相同
            
        - 空栈：base == top
            
        - 栈满 top-base == stacksize
            
        - 栈满需要报错，返回操作系统或者分配更大的空间，作为栈的存储空间
            
        - 使用数组作为顺序栈存储方式的特点：简单、方便、但容易产生溢出
            
            - 上溢出：栈满了，还要压入元素 错误
                
            - 下溢出，栈已经空了，还要弹出元素 不算错误
                
        - 顺序栈的表示
            
            - 这里其实是指针运算，计算指针间相差几个元素![image-20231004151820409](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004151820409.png?lastModify=1699273014)
                
        - 顺序栈的初始化
            
            - Status InitStack (SqStack &S){  
                    S.base = new SElemType[MAXSIZE];  
                    if(!S.base) sxit (OVERFLOW);  
                    S.top = S.base;  
                    S.stacksize = MAXSIZE;  
                    return OK;  
                }
                
        - 判断栈是否为空
            
            - ![image-20231004152515943](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004152515943.png?lastModify=1699273014)
                
        - 求解栈长度
            
            - int StackLength(SqStack S)  
                {  
                    return S.stop-S.base;  
                }
                
        - 清空顺序栈
            
            - ![image-20231004152700547](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004152700547.png?lastModify=1699273014)
                
        - 销毁顺序栈
            
            - ![image-20231004152824419](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004152824419.png?lastModify=1699273014)
                
        - 顺序栈的入栈
            
            - 算法思路
                
                - 判断是否栈满，若栈满出错
                    
                - 元素e压入栈顶
                    
                - 栈顶指针+1
                    
            - 算法展示
                
                - Status Push (SqStack &S,SElemType e){  
                        if(S.stop - S.base == S.stacksize)//判断是否栈满  
                            return ERROR;  
                        *S.top++=e;  //*S.top=e S.top++  
                        return OK;  
                    }
                    
        - 顺序栈的出栈
            
            - 算法思路
                
                - 判断是否栈空，若空着出错
                    
                - 获取栈顶元素e
                    
                - 栈顶指针-1
                    
            - 算法展示
                
                - Status Pop(SqStack &S,SElemType &e){  
                        if(S.stop - S.base == S.stacksize)//判断是否栈满  
                            return ERROR;  
                        e=*--S.stop //S.stop-1;e=*S.stop;  
                        return OK;  
                    }
                    
    - **链栈的表示和实现**
        
        - 链栈是运算受限的单链表，只能在链表头部进行操作![image-20231004154918414](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004154918414.png?lastModify=1699273014)
            
        - 链栈的初始化
            
            - ![image-20231004155321478](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004155321478.png?lastModify=1699273014)
                
        - 判断链栈是否为空
            
            - ![image-20231004155347805](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004155347805.png?lastModify=1699273014)
                
        - 链栈的入栈
            
            - ![image-20231004155547245](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004155547245.png?lastModify=1699273014)
                
        - 链栈的出栈
            
            - ![image-20231004155753816](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004155753816.png?lastModify=1699273014)
                
        - 取出栈顶元素
            
            - ![image-20231004155951934](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004155951934.png?lastModify=1699273014)
                
    - **栈与递归**
        
        - 递归：一个对象部分包含自己，或自己给自己定义；一个过程直接地或间接地调用自己
            
            - 递归定义的数学函数：阶乘函数，二阶斐波那契数列
                
            - 具有递归特性的数据结构：二叉树，广义表
                
            - 可递归求解的问题：迷宫问题，汉诺塔问题
                
            - 分而治之：能够将一个问题转变为一个新问题，可以用上述转化是问题简化，有一个明确的递归出口，称为递归的边界
                
            - ![image-20231004160511197](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004160511197.png?lastModify=1699273014)
                
        - 函数调用过程
            
            - 调用前，系统完成
                
                - 实参，返回地址等传递给被调用函数
                    
                - 为被调用函数的局部变量分配存储区
                    
                - 将控制转移到被调用函数的入口
                    
            - 调用后，系统完成
                
                - 保存被调用函数的就删结果
                    
                - 释放被调用函数的数据区
                    
                - 依照被调用函数保存的返回地址将控制转移到函数
                    
            - 函数递归利用栈来实现
                
                - ![image-20231004161459388](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004161459388.png?lastModify=1699273014)最先调用的最后返回，最后调用的最先返回
                    
                - 递归的优缺点
                    
                    - 优点：结构清晰，程序易读
                        
                    - 缺点：时间复杂度较高，耗时
                        
                    - 优化方法：递归→非递归 尾递归、单项递归→循环结构；用栈模拟系统的运行时栈![image-20231004162158900](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004162158900.png?lastModify=1699273014)
                        
    - **队列的表示和操作的实现**
        
        - 队列示意图![image-20231004162317144](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004162317144.png?lastModify=1699273014)
            
        - 仅在表尾进行插入操作，在表头进行删除操作的线性表。
            
        - 队列的抽象数据类型定义![image-20231004162540441](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004162540441.png?lastModify=1699273014)
            
        - 解决假上溢的方法
            
            - ![image-20231004164303325](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004164303325.png?lastModify=1699273014)
                
            - 引入循环队列
                
                - base[0]接在base[MAXSIZE-1]之后，若rear+1==M，则rear=0；
                    
                - 实现方法：利用模（mod，C语言中：%）运算
                    
                - 插入元素：![image-20231004164720196](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004164720196.png?lastModify=1699273014)
                    
                - 删除元素：![image-20231004164738457](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004164738457.png?lastModify=1699273014)
                    
            - 队空和队满标志相同如何解决？
                
                - 设置一个标志却别队空，队满
                    
                - 另设一个变量，记录员数个数
                    
                - ==少用一个元素空间==
                    
                - 队空：front= =rear；队满：（rear+1）%MAXSIZE==front
                    
            - 循环链表的操作
                
                - 队列的初始化
                    
                    - Status InitQueue (SqQuene &Q){  
                            Q,base=new QElemType[MAXSIZE];//分配数组空间  
                            if(!Q.bas) exit (OVERFLOW); //存储分配失败  
                            Q.front = Q,rear = 0; //头指针尾指针设置为0，队列为空  
                            return OK;  
                        }
                        
                - 求队列的长度
                    
                    - 算法思路：![image-20231004170105810](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004170105810.png?lastModify=1699273014)
                        
                - 循环队列入队
                    
                    - 算法思路：先判断是否队满；新元素加入队尾；队尾指针++1![image-20231004171154368](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004171154368.png?lastModify=1699273014)
                        
                - 循环队列出队
                    
                    - 算法思路：是否队空；保留队头元素，队头指针+1![image-20231004171320982](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004171320982.png?lastModify=1699273014)
                        
                - 取队头元素
                    
                    - 算法思路：队列不为空；返回队头指针元素的值，队头指针不变![image-20231004171423086](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004171423086.png?lastModify=1699273014)
                        
                - 循环队列的类型定义![image-20231004171529901](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004171529901.png?lastModify=1699273014)
                    
        - 链队列的类型定义
            
            - #define MAXSIZE 100  
                typedef struct Qnode{  
                    QElemType data;  
                    struct Qnode *next;  
                }QNode,*QuenePtype
                
            - 链队列的初始化
                
                - Status InitQueue (LinkQueue &Q){  
                        Q.front=Q.rear=(Queuetr)malloc(sizeof(  QNode));  
                        if(!Q.front) exit(OVERFLOW);  
                        Q.front ->next=NULL;  
                        return OK;  
                    }
                    
            - 链队列的销毁
                
                - 算法思想：从头结点开始，依次释放所有节点
                    
                - 算法展示：![image-20231004172952181](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004172952181.png?lastModify=1699273014)
                    
            - 将元素e入队
                
                - 算法展示：![image-20231004173216043](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004173216043.png?lastModify=1699273014)
                    
            - 链队列出列
                
                - 算法展示![image-20231004173348396](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004173348396.png?lastModify=1699273014)
                    
            - 求解链队列的队头元素
                
                - 算法展示：![image-20231004173508665](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231004173508665.png?lastModify=1699273014)
                    
- 串，数组和广义表
    
    - 串（string）
        
        - 零个或多个任意字符组成的有限序列
            
        - ![image-20231005092134361](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231005092134361.png?lastModify=1699273014)
            
        - 子串：串中任意个连续字符组成的子序列成为该串的子串
            
        - 字符位值：字符在序列中的序号为该字符在串中的位置
            
        - 子串位置，子串第一个字符在主串中的位置
            
        - 空格串：由一个或者多个空格组成
            
        - 串的抽象类型数据定义
            
            - ![image-20231005094157380](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231005094157380.png?lastModify=1699273014)
                
                ![image-20231005094320766](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231005094320766.png?lastModify=1699273014)
                
        - 串的顺序存储结构（用的更多，一般就是查找……
            
            - #define MaxLEN 255  
                typedef struct{  
                    cahr ch[MAXLEN+1]; //储存串的一维数组  
                    int length; //串的当前长度  
                }SString
                
        - 串的链式存储结构
            
            - 操作方便 存储密度低（可以将多个字符放在一个节点中，克服缺点）
                
            - ![image-20231005095216217](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231005095216217.png?lastModify=1699273014)
                
        - 串的模式匹配算法
            
            - 算法目的：确定主串中所含子串（模式串）第一次出现的位置（定位）
                
            - 算法应用：搜索引擎、拼写检查、语言翻译
                
            - 算法种类：BF算法、KMP算法
                
            - BF算法
                
                - 逐个比较，如果相等就比较下一位，如果比配失败就是i-j+2 ，j=1
                    
                - 算法展示：
                    
                    int Index_BF(SString S,SString T){  
                        int i=1.j=1;  
                        while(i<=S,length && j<=T,length){  
                            if(s.ch[i]==t.ch[j]){ //主串和子串依次匹配下一字符  
                                ++i;  
                                ++j;  
                            }  
                            else{ //两串回溯重新开始下一次匹配  
                                i=i-j+2;  
                                j=1;  
                            }  
                        }  
                        if(j>=T,length) return i-T.length; //返回匹配的第一个字符的下标  
                        else return 0; //匹配失败  
                    }
                    
                    时间复杂度为O(m*n)
                    
    - 数组
        
        - 具有想同类型的数据元素的集合
            
        - 一维数组：线性表中的数据元素为非结构的简单元素；线性结构，定长的线性表。
            
        - 二维数组：若一维数组中的数据元素又是一堆数据结构，称为二维数组。线性结构，非线性结构，定长的线性表
            
        - typedef elelmtype array2[n] [m] typedefe elemtype array1[n] typedef elemtype array1array[m]
            
        - 线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展
            
        - 数组的抽象数据类型定义
            
            - ![image-20231005122718858](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231005122718858.png?lastModify=1699273014)
                
            - ![image-20231005122927296](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231005122927296.png?lastModify=1699273014)
                
            - ![image-20231005122949599](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231005122949599.png?lastModify=1699273014)
                
        - 数组特点：结构固定；数组基本操作：初始化、销毁、取元素……
            
        - 一般采用顺序存储结构来表示数组
            
        - 二维数组以行序为主序：假设数组开始存储位置LOC（0,0），存储每个元素需要L个存储单元，数组元素a[i] [j]的存储位置是：LOC（i，j）=LOC(0,0)+(n*i+j) * L
            
        - 三维数组：页，行，列 ；LOC(i1,i2,i3)=a+……
            
        - n维数组计算：![image-20231006153915756](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006153915756.png?lastModify=1699273014)
            
    - 特殊矩阵的压缩存储
        
        - 矩阵：一个由m×n个元素排成的m行n列的表
            
        - 矩阵的常规存储：将矩阵描述为一个二维数组
            
        - 什么是压缩存储？
            
            - 若多个元素的值都相同，值分配一个元素值的存储空间，且零元素不占存储空间
                
            - 对称矩阵，对角矩阵，三角矩阵，稀疏矩阵（矩阵中非零元素个数教少（一般小于5%）
                
                - 对称矩阵：![image-20231006154721670](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006154721670.png?lastModify=1699273014)
                    
                    - 下三角矩阵以行序为主序将元素存放在一个一维数组sa[n(n+1)/2]中——aij= i*(i-1)/2+j-1
                        
                - 三角矩阵：与对称矩阵的下三角存储相似，存入一个一维数组![image-20231006155403979](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006155403979.png?lastModify=1699273014)
                    
                - 对角矩阵（带状矩阵）：直接只存入非零元素，使用二维数组存储，一条对角线一条对角线的存储![image-20231006155904002](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006155904002.png?lastModify=1699273014)
                    
                - 稀疏矩阵：设在m×n的矩阵中有t个非零元素。使用三元组法![image-20231006160646412](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006160646412.png?lastModify=1699273014)
                    
                    - 三元组顺序表：![image-20231006160840359](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006160840359.png?lastModify=1699273014)
                        
                    - 有序的双下标法：优点：按行序有序存储，便于进行依行顺序处理的矩阵运算 缺点：不能够随机存储，查找需要从头开始查找
                        
                    - 稀疏矩阵对的链式存储结构：十字链表
                        
                        - 优点：能够灵活地插入因运算产生的新的非零元素，删除非零元素
                            
                        - ![image-20231006161551248](file://C:/Users/20418/Desktop/Collection/Study%20record/MarkDown/image-20231006161551248.png?lastModify=1699273014)
                            
    - 广义表
        
        - 又称为列表，每一个aI都是原子，或是一个广义表
            
        - ![image-20231006162052230](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006162052230.png?lastModify=1699273014)
            
        - 广义表的各种构成![image-20231006162450517](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006162450517.png?lastModify=1699273014)
            
        - 广义表的性质![image-20231006162713269](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006162713269.png?lastModify=1699273014)
            
            ![image-20231006162807834](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006162807834.png?lastModify=1699273014)
            
        - 广义表与线性表的区别
            
            - 光一波啊是线性表的推广，线性表是广义表的特例
                
            - 二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表
                
        - 广义表的基本运算
            
            - 求表头：非空广义表的第一个元素
                
            - 求表尾：非空广义表出去表头元素以外其他元素所构成的表，表尾一定是一个表
                
            - 例子：![image-20231006163237729](file://C:/Users/20418/AppData/Roaming/Typora/typora-user-images/image-20231006163237729.png?lastModify=1699273014)
                
[[图]]
